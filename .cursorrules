# FastAPI Enterprise Application - Cursor Rules

## Project Overview

Enterprise-grade FastAPI application implementing **Hexagonal Architecture** (Ports & Adapters) with **Functional Core, Imperative Shell (FCIS)** pattern. Manufacturing pricing calculations and cost management for custom parts.

## ðŸš¨ CRITICAL: Standard Practices First

**ALWAYS follow standard, documented patterns.** If you need to deviate from:
- Framework conventions (FastAPI, SQLAlchemy, Pydantic)
- Architectural patterns (hexagonal architecture, FCIS)
- Python standards (PEP 8, type hints)
- Industry best practices (REST API, security)

**Stop and check with the project owner first. Do not reinvent the wheel.**

## Quick Reference

### Project Structure (Hexagonal Architecture)

```
app/
â”œâ”€â”€ adapter/                    # Adapters (Imperative Shell)
â”‚   â”œâ”€â”€ inbound/               # Primary adapters (driving)
â”‚   â”‚   â””â”€â”€ web/               # HTTP/REST API layer
â”‚   â”‚       â”œâ”€â”€ pricing.py     # FastAPI routes/controllers
â”‚   â”‚       â”œâ”€â”€ schemas.py     # Request/response DTOs
â”‚   â”‚       â”œâ”€â”€ dependencies.py # Dependency injection
â”‚   â”‚       â””â”€â”€ metrics_middleware.py # HTTP middleware
â”‚   â””â”€â”€ outbound/              # Secondary adapters (driven)
â”‚       â”œâ”€â”€ persistence/       # Database adapters
â”‚       â”‚   â”œâ”€â”€ cost_data_adapter.py
â”‚       â”‚   â””â”€â”€ pricing_config_adapter.py
â”‚       â””â”€â”€ telemetry/         # Metrics/observability adapters
â”‚           â”œâ”€â”€ metrics_adapter.py
â”‚           â””â”€â”€ golden4_metrics_adapter.py
â”œâ”€â”€ core/                      # Application Core
â”‚   â”œâ”€â”€ domain/               # Domain Layer (Functional Core)
â”‚   â”‚   â”œâ”€â”€ pricing/          # Pricing domain with subdomains
â”‚   â”‚   â”‚   â”œâ”€â”€ models.py     # Base pricing models
â”‚   â”‚   â”‚   â”œâ”€â”€ calculations.py # Base calculations
â”‚   â”‚   â”‚   â”œâ”€â”€ tier/         # Tier subdomain
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ models.py     # PricingTier, TierPricing
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ calculations.py # Tier pricing logic
â”‚   â”‚   â”‚   â”œâ”€â”€ discount/     # Discount subdomain
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ calculations.py # Volume & final discounts
â”‚   â”‚   â”‚   â””â”€â”€ margin/       # Margin subdomain
â”‚   â”‚   â”‚       â””â”€â”€ calculations.py # Margin calculations
â”‚   â”‚   â””â”€â”€ cost/
â”‚   â”‚       â”œâ”€â”€ models.py
â”‚   â”‚       â””â”€â”€ calculations.py
â”‚   â”œâ”€â”€ application/          # Application Layer (Orchestration)
â”‚   â”‚   â””â”€â”€ pricing/
â”‚   â”‚       â””â”€â”€ use_cases.py  # Coordinates functional core + adapters
â”‚   â”œâ”€â”€ port/                 # Ports (Interfaces)
â”‚   â”‚   â”œâ”€â”€ inbound/          # Use case interfaces
â”‚   â”‚   â””â”€â”€ outbound/         # Repository/service interfaces
â”‚   â”‚       â”œâ”€â”€ cost_ports.py
â”‚   â”‚       â”œâ”€â”€ pricing_ports.py
â”‚   â”‚       â””â”€â”€ metrics_ports.py
â”‚   â”œâ”€â”€ config.py             # Application configuration
â”‚   â”œâ”€â”€ database.py           # Database connection management
â”‚   â””â”€â”€ telemetry.py          # OpenTelemetry setup
â””â”€â”€ main.py                   # FastAPI application entry point
```

### Dependency Flow (Dependencies Point Inward)

```
Inbound Adapters (Web) â†’ Application (Use Cases) â†’ Domain (Pure Logic)
                      â†—                        â†—
Outbound Adapters (DB/Metrics) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Rules:**
- Domain layer: NO external dependencies (pure functions)
- Application layer: Depends only on domain + port interfaces
- Adapters: Implement ports but don't depend on other layers
- Web layer: Depends on application + domain

## Architecture Patterns

### 1. Functional Core, Imperative Shell (FCIS)

**Functional Core (Domain)**: Pure functions, no side effects
```python
# app/core/domain/pricing/calculations.py
def calculate_material_cost(
    volume_cm3: float,
    material_density: float,
    material_cost_per_kg: Decimal,
    quantity: int
) -> Decimal:
    """Pure function - no I/O, no side effects"""
    volume_m3 = volume_cm3 / 1_000_000
    weight_kg = volume_m3 * material_density
    return material_cost_per_kg * Decimal(str(weight_kg)) * quantity
```

**Imperative Shell (Adapters)**: All I/O and side effects
```python
# app/adapter/outbound/persistence/cost_data_adapter.py
class PostgresCostDataAdapter(CostDataPort):
    """Handles all database I/O"""
    async def get_material_costs(self) -> Dict[str, Decimal]:
        # Database queries happen here
        pass
```

**Application Layer (Orchestration)**: Coordinates both
```python
# app/core/application/pricing/use_cases.py
class CalculatePricingUseCase:
    async def execute(self, request: PricingRequest) -> PricingResult:
        # 1. Get data (imperative shell)
        material_costs = await self._cost_port.get_material_costs()

        # 2. Pure calculation (functional core)
        result = calculate_material_cost(...)

        # 3. Persist (imperative shell)
        await self._metrics_port.record_calculation(result)
        return result
```

### 2. Key Principles

**Functional Core (Domain Layer):**
- âœ… Pure functions that return same output for same input
- âœ… All data passed as parameters
- âœ… Immutable data structures
- âŒ NO I/O operations (database, HTTP, file system)
- âŒ NO global state or side effects
- âŒ NO logging or datetime.now() calls

**Imperative Shell (Adapters):**
- âœ… All I/O operations (database, HTTP, cache)
- âœ… Transaction management
- âœ… Convert between domain and external formats
- âŒ NO business logic
- âŒ NO business decisions

**Application Layer (Use Cases):**
- âœ… Orchestrate functional core + imperative shell
- âœ… Gather data â†’ call pure functions â†’ persist results
- âŒ NO business logic (delegate to domain)
- âŒ NO direct I/O (delegate to adapters)

## Development Workflow

### Common Commands

```bash
make install        # Install dependencies with uv
make start-dev      # Run development server
make test           # Run all tests
make test-unit      # Fast tests (pure functions)
make format         # Format code
make lint           # Check code quality
make check-all      # Run all checks
make db-upgrade     # Run migrations
```

### Adding a New Feature

1. **Domain Layer**: Write pure functions (no mocks needed for tests!)
2. **Port Interfaces**: Define interfaces in `core/port/outbound/`
3. **Adapters**: Implement interfaces in `adapter/outbound/`
4. **Use Cases**: Orchestrate in `core/application/`
5. **Web Layer**: Add routes in `adapter/inbound/web/`

See [docs/development/adding-features.md](docs/development/adding-features.md) for detailed guide.

## Code Standards

### Python Standards
- Python 3.11+ with type hints everywhere
- Black formatting (line length: 88)
- Use `uv` for package management
- Pydantic for validation
- Async/await where needed (not in pure domain logic)

### Testing Strategy
- **Domain tests**: Test pure functions directly (no mocks!)
- **Integration tests**: Test adapters with real dependencies
- **Application tests**: Mock adapters, use real domain logic
- **API tests**: Mock use cases, test HTTP concerns

```python
# âœ… Domain test - no mocks needed
def test_calculate_material_cost():
    result = calculate_material_cost(1000.0, 2.7, Decimal("10.50"), 100)
    assert result == Decimal("2835.00")

# âœ… Use case test - mock adapters, real domain logic
async def test_pricing_use_case():
    mock_cost_port = Mock(spec=CostDataPort)
    mock_cost_port.get_material_costs.return_value = {"aluminum": Decimal("10.50")}

    use_case = CalculatePricingUseCase(mock_cost_port)
    result = await use_case.execute(request)

    assert result.total_cost > 0
    mock_cost_port.get_material_costs.assert_called_once()
```

### Before Committing
```bash
make check-all      # Format, lint, type-check
make test           # All tests
```

## Stack

- **Package Manager**: [uv](https://github.com/astral-sh/uv)
- **Framework**: [FastAPI](https://fastapi.tiangolo.com/)
- **Databases**: PostgreSQL, MongoDB, Redis
- **ORM**: SQLAlchemy (async), Beanie (MongoDB)
- **Validation**: Pydantic v2
- **Testing**: pytest
- **Observability**: OpenTelemetry, Prometheus, Grafana
- **Background**: Celery
- **Migrations**: Alembic

## Documentation

For detailed information:
- [Architecture Overview](docs/architecture/README.md) - Hexagonal architecture deep dive
- [Folder Structure](docs/architecture/folder-structure.md) - Detailed file organization
- [Development Guide](docs/development/README.md) - Feature development workflow
- [Operations Guide](docs/operations/README.md) - Deployment & monitoring
- [Golden 4 Metrics](docs/operations/golden4-metrics.md) - Observability metrics

## Common Anti-Patterns to Avoid

### General
- âŒ Business logic in route handlers
- âŒ Database models imported in domain layer
- âŒ Global variables for state
- âŒ Missing type annotations
- âŒ Exposing internal exceptions to API

### FCIS-Specific
- âŒ Side effects in domain functions
- âŒ Database calls from domain layer
- âŒ Using datetime.now() in pure functions
- âŒ Logging in functional core
- âŒ Mocking pure functions in tests

### Testing
- âŒ Mocking pure functions (test them directly!)
- âŒ Testing pure domain logic with integration tests
- âŒ Testing adapters and domain together in unit tests

## Quick Examples

### FastAPI Route (Inbound Adapter)
```python
@router.post("/pricing", response_model=PricingResponse)
async def calculate_pricing(
    request: PricingRequest,
    use_case: CalculatePricingUseCase = Depends(get_pricing_use_case),
) -> PricingResponse:
    try:
        result = await use_case.execute(request)
        return PricingResponse.from_domain(result)
    except DomainError as e:
        raise HTTPException(status_code=400, detail=str(e))
```

### Port Interface
```python
class CostDataPort(Protocol):
    """Port for cost data access"""
    async def get_material_costs(self) -> Dict[str, Decimal]: ...
```

### Pure Domain Function
```python
def calculate_pricing(
    volume_cm3: float,
    material_cost_per_kg: Decimal,
    labor_rate_per_hour: Decimal,
    # All data passed as parameters
) -> PricingResult:
    # Pure calculation - no side effects
    return PricingResult(...)
```

## Environment Setup

```bash
# Clone and setup
git clone <repo-url>
cd fastapi_enterprise
cp .env.example .env

# One command setup
make full-setup     # Starts services, installs deps, runs migrations

# Start coding
make start-dev
```

See [README.md](README.md) for complete quick start guide.

---

**Remember**: Keep domain logic pure, push all side effects to adapters, orchestrate in use cases. This makes the codebase maintainable, testable, and reliable.
