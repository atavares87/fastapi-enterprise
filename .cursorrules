# FastAPI Enterprise Application - Cursor Rules

## Project Overview

Enterprise-grade FastAPI application implementing **Layered Architecture** (Spring Boot style) with **Functional Core** for business logic. Manufacturing pricing calculations and cost management for custom parts.

## ðŸš¨ CRITICAL: Standard Practices First

**ALWAYS follow standard, documented patterns.** If you need to deviate from:
- Framework conventions (FastAPI, SQLAlchemy, Pydantic)
- Architectural patterns (Layered Architecture, Spring Boot patterns)
- Python standards (PEP 8, type hints)
- Industry best practices (REST API, security)

**Stop and check with the project owner first. Do not reinvent the wheel.**

## Quick Reference

### Project Structure (Layered Architecture)

```
app/
â”œâ”€â”€ controller/                  # REST endpoints (@RestController in Spring)
â”‚   â”œâ”€â”€ pricing_controller.py   # Pricing API endpoints
â”‚   â””â”€â”€ health_controller.py    # Health check endpoints
â”‚
â”œâ”€â”€ service/                     # Business logic (@Service in Spring)
â”‚   â””â”€â”€ pricing_service.py      # Pricing business orchestration
â”‚
â”œâ”€â”€ repository/                  # Data access (@Repository in Spring)
â”‚   â”œâ”€â”€ cost_repository.py
â”‚   â”œâ”€â”€ config_repository.py
â”‚   â”œâ”€â”€ pricing_repository.py
â”‚   â””â”€â”€ metrics_repository.py
â”‚
â”œâ”€â”€ domain/                      # Core domain
â”‚   â”œâ”€â”€ model/                   # Domain models (entities, value objects)
â”‚   â”‚   â”œâ”€â”€ enums.py
â”‚   â”‚   â”œâ”€â”€ cost_models.py
â”‚   â”‚   â””â”€â”€ pricing_models.py
â”‚   â””â”€â”€ core/                    # Functional Core (pure functions)
â”‚       â”œâ”€â”€ cost/
â”‚       â”‚   â””â”€â”€ calculations.py
â”‚       â””â”€â”€ pricing/
â”‚           â”œâ”€â”€ calculations.py
â”‚           â”œâ”€â”€ tier_calculations.py
â”‚           â”œâ”€â”€ discount_calculations.py
â”‚           â””â”€â”€ margin_calculations.py
â”‚
â”œâ”€â”€ dto/                         # Data Transfer Objects
â”‚   â”œâ”€â”€ request/
â”‚   â””â”€â”€ response/
â”‚
â”œâ”€â”€ exception/                   # Exception handling
â”‚   â”œâ”€â”€ domain_exceptions.py
â”‚   â””â”€â”€ handler.py
â”‚
â”œâ”€â”€ config/                      # Configuration
â”‚   â”œâ”€â”€ settings.py
â”‚   â””â”€â”€ dependencies.py          # Dependency injection
â”‚
â”œâ”€â”€ infrastructure/              # Cross-cutting infrastructure
â”‚   â”œâ”€â”€ database.py
â”‚   â”œâ”€â”€ logging.py
â”‚   â””â”€â”€ telemetry.py
â”‚
â””â”€â”€ main.py                      # Application entry point
```

### Dependency Flow (Top to Bottom)

```
Controller â†’ Service â†’ Repository â†’ Domain
```

**Rules:**
- Controllers depend on Services and DTOs
- Services depend on Repositories and Domain
- Repositories depend on Domain Models
- Domain has NO external dependencies

## Architecture Layers

### 1. Controller Layer (`controller/`)

**Responsibility**: Handle HTTP requests and responses

**Analogous to**: Spring `@RestController`

**Rules**:
- Route HTTP requests to service methods
- Validate requests (Pydantic does this automatically)
- Convert DTOs to/from HTTP
- Handle HTTP-specific concerns (status codes, headers)
- **NO business logic**

**Example**:
```python
@router.post("/calculate", response_model=PricingResponseDTO)
async def calculate_pricing(
    request: PricingRequestDTO,
    pricing_service: PricingService = Depends(get_pricing_service)
) -> PricingResponseDTO:
    """Delegate to service layer for business logic."""
    return await pricing_service.calculate_pricing(request)
```

### 2. Service Layer (`service/`)

**Responsibility**: Business logic orchestration

**Analogous to**: Spring `@Service`

**Rules**:
- Orchestrate business workflows
- Coordinate between repositories
- Call domain core functions for calculations
- Handle business rules and validation
- **NO HTTP concerns**
- **NO database implementation details**

**Example**:
```python
class PricingService:
    def __init__(
        self,
        cost_repository: CostRepository,
        config_repository: ConfigRepository,
        pricing_repository: PricingRepository,
        metrics_repository: MetricsRepository,
    ):
        self.cost_repository = cost_repository
        # ... other repositories

    async def calculate_pricing(self, request: PricingRequestDTO):
        # 1. Fetch data from repositories
        material_costs = await self.cost_repository.get_material_costs()

        # 2. Call domain core (pure functions)
        tier_pricing = calculate_tier_pricing(...)

        # 3. Persist results
        await self.pricing_repository.save(tier_pricing)

        return response_dto
```

### 3. Repository Layer (`repository/`)

**Responsibility**: Data access and persistence

**Analogous to**: Spring `@Repository`

**Rules**:
- Abstract database access
- Execute database queries
- Map database results to domain models
- Handle database transactions
- Cache management
- **NO business logic**

**Example**:
```python
class CostRepository:
    async def get_material_costs(self) -> dict[Material, MaterialCost]:
        # Database access here
        return await self._fetch_from_database()
```

### 4. Domain Layer (`domain/`)

**Responsibility**: Core business domain

**Two sub-layers**:

#### Domain Models (`domain/model/`)
- Entity classes (dataclasses)
- Value objects
- Enums
- **NO I/O operations**

#### Functional Core (`domain/core/`)
- **Pure functions** (no side effects)
- Core business calculations
- Business rules
- **NO I/O, NO database, NO HTTP, NO logging**
- **NO mutable state**
- **Completely testable without mocks**

**Example**:
```python
def calculate_complexity_surcharge(
    cost_plus_margin: Decimal,
    complexity_score: float,
    config: PricingConfiguration,
) -> Decimal:
    """Pure function - same input always produces same output."""
    if complexity_score >= config.complexity_surcharge_threshold:
        return cost_plus_margin * Decimal(str(config.complexity_surcharge_rate))
    return Decimal("0")
```

## Development Workflow

### Common Commands

```bash
make install        # Install dependencies with uv
make start-dev      # Run development server
make test           # Run all tests
make test-unit      # Fast tests (pure functions)
make format         # Format code
make lint           # Check code quality
make check-all      # Run all checks
make db-upgrade     # Run migrations
```

### Adding a New Feature

1. **Domain Layer**: Write domain models and pure functions (no mocks needed for tests!)
2. **Repository Layer**: Create repository for data access
3. **Service Layer**: Create service with business orchestration
4. **Controller Layer**: Add routes and HTTP schemas (DTOs)
5. **Dependency Injection**: Wire dependencies in `config/dependencies.py`

## Code Standards

### Python Standards
- Python 3.11+ with type hints everywhere
- Black formatting (line length: 88)
- Use `uv` for package management
- Pydantic for validation
- Async/await where needed (not in pure domain core)

### Testing Strategy

**Domain Core Tests**: Test pure functions directly (no mocks!)
```python
def test_calculate_complexity_surcharge():
    result = calculate_complexity_surcharge(
        Decimal("100"), 4.0, PricingConfiguration(...)
    )
    assert result == Decimal("20.00")
```

**Service Tests**: Mock repositories, use real domain logic
```python
async def test_pricing_service():
    mock_repo = Mock(spec=CostRepository)
    mock_repo.get_material_costs.return_value = {...}

    service = PricingService(mock_repo, ...)
    result = await service.calculate_pricing(request_dto)

    assert result.pricing_tiers.standard.final_price > 0
    mock_repo.get_material_costs.assert_called_once()
```

**Controller Tests**: Mock services, test HTTP concerns
```python
async def test_pricing_endpoint(client):
    response = client.post("/api/v1/pricing/calculate", json=request_data)
    assert response.status_code == 200
```

### Before Committing
```bash
make check-all      # Format, lint, type-check
make test           # All tests
```

## Stack

- **Package Manager**: [uv](https://github.com/astral-sh/uv)
- **Framework**: [FastAPI](https://fastapi.tiangolo.com/)
- **Databases**: PostgreSQL, MongoDB, Redis
- **ORM**: SQLAlchemy (async), Beanie (MongoDB)
- **Validation**: Pydantic v2
- **Testing**: pytest
- **Observability**: OpenTelemetry, Prometheus, Grafana
- **Background**: Celery
- **Migrations**: Alembic

## SOLID Principles Adherence

### Single Responsibility Principle (SRP)
- Each layer has one reason to change
- Controllers: HTTP changes
- Services: Business logic changes
- Repositories: Data access changes
- Domain: Business rules changes

### Open/Closed Principle (OCP)
- Services are open for extension via new methods
- Domain core functions are pure and composable

### Liskov Substitution Principle (LSP)
- Repository implementations are interchangeable
- Service implementations can be swapped

### Interface Segregation Principle (ISP)
- Repository interfaces are focused and specific
- Services only depend on what they need

### Dependency Inversion Principle (DIP)
- Services depend on repository abstractions
- Services depend on domain models, not infrastructure

## Common Anti-Patterns to Avoid

### General
- âŒ Business logic in controllers
- âŒ HTTP concerns in services
- âŒ Database queries in services (use repositories)
- âŒ Global variables for state
- âŒ Missing type annotations

### Layered Architecture-Specific
- âŒ Controllers calling repositories directly (skip service layer)
- âŒ Services knowing about HTTP (status codes, headers)
- âŒ Repositories containing business logic
- âŒ Domain depending on any layer above it

### Functional Core-Specific
- âŒ Side effects in domain core functions
- âŒ Database calls from domain core
- âŒ Using `datetime.now()` in pure functions
- âŒ Logging in functional core
- âŒ Mocking pure functions in tests

## Dependency Injection

Using `functools.lru_cache` for singleton pattern (analogous to Spring `@Bean`):

```python
# config/dependencies.py
from functools import lru_cache

@lru_cache()
def get_cost_repository() -> CostRepository:
    return CostRepository()

@lru_cache()
def get_pricing_service() -> PricingService:
    return PricingService(
        cost_repository=get_cost_repository(),
        config_repository=get_config_repository(),
        pricing_repository=get_pricing_repository(),
        metrics_repository=get_metrics_repository(),
    )
```

## Quick Examples

### Controller (HTTP Layer)
```python
# controller/pricing_controller.py
@router.post("/calculate", response_model=PricingResponseDTO)
async def calculate_pricing(
    request: PricingRequestDTO,
    pricing_service: PricingService = Depends(get_pricing_service)
) -> PricingResponseDTO:
    return await pricing_service.calculate_pricing(request)
```

### Service (Business Logic)
```python
# service/pricing_service.py
class PricingService:
    async def calculate_pricing(self, request: PricingRequestDTO):
        # Orchestrate: repositories + domain core
        costs = await self.cost_repository.get_material_costs()
        tier_pricing = calculate_tier_pricing(costs, ...)
        await self.pricing_repository.save(tier_pricing)
        return response_dto
```

### Repository (Data Access)
```python
# repository/cost_repository.py
class CostRepository:
    async def get_material_costs(self):
        return await self._fetch_from_database()
```

### Domain Core (Pure Functions)
```python
# domain/core/pricing/calculations.py
def calculate_margin(base_cost: Decimal, config: PricingConfiguration) -> Decimal:
    """Pure function - no side effects."""
    return base_cost * Decimal(str(config.margin_percentage))
```

## Environment Setup

```bash
# Clone and setup
git clone <repo-url>
cd fastapi_enterprise
cp .env.example .env

# One command setup
make full-setup     # Starts services, installs deps, runs migrations

# Start coding
make start-dev
```

## Documentation

For detailed information:
- [Layered Architecture](docs/architecture/layered-architecture.md) - Complete architecture guide
- [Folder Structure](docs/architecture/folder-structure.md) - Detailed file organization
- [Development Guide](docs/development/README.md) - Feature development workflow
- [Operations Guide](docs/operations/README.md) - Deployment & monitoring

---

**Remember**: Keep domain core pure, services orchestrate, repositories handle data, controllers handle HTTP. Dependencies flow downward toward the domain. This makes the codebase maintainable, testable, and reliable.
